# Pseudocode – Serial Dilution Optimisation Pipeline

This document describes the logic of the three main scripts in this project:

- **Code A** – generator script  
- **Code B** – execution scripts (Opentrons protocols)  
- **Code C** – analysis script  

## Code A – Generator Script 

**Purpose:**  
Read a JMP design-of-experiment file and generate an Opentrons code which carries out serial dilution for each set of parameters.

**Inputs:**
- `DESIGN_CSV`
- `Default_Params`

**Outputs:**
- Autogenerated protocol files:  
  `serial_dilution_BB_exp_1.py`, `serial_dilution_BB_exp_2.py`, …

**Pseudocode:**

```text
BEGIN
  
-Set a list of potential parameters to default values. Global parameters are broken down into parameters specific to each serial dilution step. Global parameters are given a default value.

-Load the JMP table as DESIGN_CSV. 

-Define a code-maker function which takes two arguments: a dictionary of parameters; and an experiment number:
    
    Convert the parameters to a string.
    
    Return an f string which contains the parameters dictionary and a template serial dilution code (explained as Code B), with the experiment number saved in the file name.

-Define a code-writer function which produces opentron files:
    
    Use the dictionary reader function to save a parameter dictionary for each row of the table.
    
    For each row in the table with index 'idx':
      Set the experiment_id as idx
      
      Calculate start_col from idx to ensure the opentron file starts loading tips from the correct position in the tip rack.
      
      Create a parameters dictionary as a copy of the default parameters.
      
      For each parameter name in the parameters dictionary:
        If the design file contains parameter k AND the corresponding row is not empty then:
          Convert default value to the JMP value and store value in parameters dictionary.
      
      Add the tip start column to the end of the parameters dictionary.
      
      Apply inheritance rules: 
        Unassigned global parameters are set to defaults.
        Unassigned step-specific parameters are set to their global parameters.
        Unassigned minimum and maximum mix height range parameters are set to the constant mix height parameters.
        Unassigned final mix rate are set to the mix rate parameter.
      
      The final parameters dictionary and experiment_id are passed as arguments to the make_protocol_code function.
      
      The returned protocol code is written as a new file:
        "serial_dilution_BB_exp_<experiment_id>.py"

  END FOR

END
```

## Code B – Execution Script

**Purpose:**  
Use the chosen parameters to run an automated serial dilution on the OT-2.

**Inputs:**

- `PARAMS`(embedded by Code A)

**Outputs:**

- A 96-well plate containing a completed serial dilution.

**Pseudocode:**

```text
BEGIN run(protocol):

  LOAD destination plate, reservoir, and tiprack
  LOAD p300 multi-channel pipette

  READ all relevant PARAMS (rates, heights, mix settings, tip start column)
  DEFINE constants: fluorescein_volume, pbs_volume, dilution_volume
  COMPUTE mix_volume = (dilution_volume + pbs_volume) * Mixing_Fraction

  ASSIGN reservoir wells: fluorescein_src, pbs_src, waste
  SELECT tips based on start_col

  PICK UP fluor_tip
  ASPIRATE fluorescein from reservoir using aliquot settings
  DISPENSE into plate column 1
  DROP TIP

  PICK UP pbs_tip
  FOR each column from 2 to 12:
      ASPIRATE PBS using aliquot settings
      DISPENSE into destination column
  DROP TIP

  PICK UP dilution_tip
  FOR col = 1 to 10:
      ASPIRATE dilution volume from plate[col]
      DISPENSE into plate[col+1]

      FOR i = 1 to Mixing_Repetitions:
          CHOOSE random aspiration height between Mix_Aspiration_Min and Max
          ASPIRATE mix_volume at that height

          CHOOSE random dispense height between Mix_Dispense_Min and Max
          DISPENSE mix_volume at that height

      TOUCH TIP using specified speed, radius, offset

  ASPIRATE small volume from second-to-last column
  DISPENSE into waste
  DROP TIP

END

```

## Code C – Analysis Script 

**Purpose:**  
Process plate-reader data to quantify dilution performance and prepare results for JMP optimisation.

**Inputs:**

Raw fluorescence/absorbance files per experiment

**Outputs:**

CSV of summary metrics (gradient, R², experiment ID)

**Pseudocode:**

```text
BEGIN

  fluorescein concentrations
  CREATE vector columns = [1, 2, ..., 11]
  CREATE vector fluor_conc where fluor_conc[i] = 10 / (2^i)
  CREATE dataframe blank_corrected with columns:
      "Column"      = columns
      "Fluor_conc"  = fluor_conc

  FOR experiment i from 1 to 15:

      READ Excel file "bb<i>.xlsx" (sheet "End point", columns B–L, 9 rows)
      FOR each of the 11 columns:
          CALCULATE mean over the 9 rows
      STORE the 11 means as a new column in blank_corrected named "df<i>_bc"

  TAKE base-10 logarithm of all numeric values in blank_corrected
  STORE as log_df

  SET x = log_df["Fluor_conc"]

  INITIALISE empty lists: slopes, r2_vals

  FOR each experiment column index col from 2 to 16 in log_df:
      SET y = log_df[column col]   # corresponds to df1_bc, df2_bc, ...

      FIT linear model y = m * x + b using polyfit
      COMPUTE predicted values y_pred = m * x + b

      COMPUTE residual sum of squares ss_res = Σ (y - y_pred)^2
      COMPUTE total sum of squares ss_tot   = Σ (y - mean(y))^2
      COMPUTE R² = 1 - ss_res / ss_tot

      APPEND slope m to slopes
      APPEND R² to r2_vals

  CREATE experiment_numbers = [1, 2, ..., 15]
  BUILD dataframe final_df with columns:
      "Experiment Number" = experiment_numbers
      "Gradient"          = slopes
      "R2"                = r2_vals

  WRITE final_df to "BB_gradient.xlsx"

  CREATE dataframe stdev with:
      "Column"     = columns
      "Fluor_conc" = fluor_conc

  FOR experiment i from 1 to 15:

      READ Excel file "bb<i>.xlsx" again (same range as before)
      FOR each of the 11 columns:
          CALCULATE standard deviation over the 9 rows
      STORE the 11 std values as a new column in stdev named "df<i>_bc"

  INITIALISE empty list global_cv

  FOR experiment column index col from 2 to 16 in w:
      CALCULATE mean CV across all 11 rows in that column
      APPEND this mean to global_cv

  PRINT global_cv  # one average CV value per experiment

END

```