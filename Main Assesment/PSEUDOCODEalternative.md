# Pseudocode – Serial Dilution Optimisation Pipeline

This document describes the logic of the three main scripts in this project:

- **Code A** – generator script  
- **Code B** – execution scripts (Opentrons protocols)  
- **Code C** – analysis script  

## Code A – Generator Script 

**Purpose:**  
Read a JMP design-of-experiment file and generate an Opentrons code which carries out serial dilution for each set of parameters.

**Inputs:**
- `DESIGN_CSV`
- `Default_Params`

**Outputs:**
- Autogenerated protocol files:  
  `serial_dilution_BB_exp_1.py`, `serial_dilution_BB_exp_2.py`, …

**Pseudocode:**

```text
BEGIN

  Set a list of potential parameters to default values. 
  Global parameters are broken down into parameters specific 
  to each serial-dilution step. Global parameters are given 
  a default value.

  LOAD the JMP table as DESIGN_CSV.

  DEFINE make_protocol_code(params, experiment_id):
    Convert params dictionary to a string representation.
    RETURN an f-string containing:
      – the parameter dictionary,
      – the experiment ID,
      – and the template serial-dilution code (Code B).

  DEFINE main code-writer function:

    LOAD the CSV using DictReader.

    FOR each row WITH index idx:
      SET experiment_id = idx
      COMPUTE start_col based on idx
      CREATE params as a copy of the default parameters
      FOR each key in params:
        IF key is a column in the CSV AND its cell is not empty:
          Convert cell to correct type and store in params
      ADD start_col to params
      APPLY inheritance rules:
        – Any step-specific aspiration rates = global rate if None
        – Any step-specific aspiration heights = global height if None
        – Mix height min/max = mix height if None
        – Step-specific dispense rates = global dispense rate if None
        – Final mix dispense rate = mix dispense rate if None
        – Step-specific dispense heights = global height if None
      GENERATE protocol code using make_protocol_code(params, experiment_id)
      WRITE the returned code to file: "serial_dilution_BB_exp_<experiment_id>.py"

    END FOR
END
```

## Code B – Execution Script

**Purpose:**  
Use the chosen parameters to run an automated serial dilution on the OT-2.

**Inputs:**

- `PARAMS`(embedded by Code A)

**Outputs:**

- A 96-well plate containing a completed serial dilution.

**Pseudocode:**

```text
BEGIN run(protocol):

  LOAD destination plate, reservoir, and tiprack
  LOAD p300 multi-channel pipette

  READ all relevant PARAMS (rates, heights, mix settings, tip start column)
  DEFINE constants: fluorescein_volume, pbs_volume, dilution_volume
  COMPUTE mix_volume = (dilution_volume + pbs_volume) * Mixing_Fraction

  ASSIGN reservoir wells: fluorescein_src, pbs_src, waste
  SELECT tips based on start_col

  PICK UP fluor_tip
  ASPIRATE fluorescein from reservoir using aliquot settings
  DISPENSE into plate column 1
  DROP TIP

  PICK UP pbs_tip
  FOR each column from 2 to 12:
      ASPIRATE PBS using aliquot settings
      DISPENSE into destination column
  DROP TIP

  PICK UP dilution_tip
  FOR col = 1 to 10:
      ASPIRATE dilution volume from plate[col]
      DISPENSE into plate[col+1]

      FOR i = 1 to Mixing_Repetitions:
          CHOOSE random aspiration height between Mix_Aspiration_Min and Max
          ASPIRATE mix_volume at that height

          CHOOSE random dispense height between Mix_Dispense_Min and Max
          DISPENSE mix_volume at that height

      TOUCH TIP using specified speed, radius, offset

  ASPIRATE small volume from second-to-last column
  DISPENSE into waste
  DROP TIP

END

```

## Code C – Analysis Script 

**Purpose:**  
Process plate-reader data to quantify dilution performance and prepare results for JMP optimisation.

**Inputs:**

Raw fluorescence/absorbance files per experiment

**Outputs:**

CSV of summary metrics (gradient, R², experiment ID)

**Pseudocode:**

```text
BEGIN

  fluorescein concentrations
  CREATE vector columns = [1, 2, ..., 11]
  CREATE vector fluor_conc where fluor_conc[i] = 10 / (2^i)
  CREATE dataframe blank_corrected with columns:
      "Column"      = columns
      "Fluor_conc"  = fluor_conc

  FOR experiment i from 1 to 15:

      READ Excel file "bb<i>.xlsx" (sheet "End point", columns B–L, 9 rows)
      FOR each of the 11 columns:
          CALCULATE mean over the 9 rows
      STORE the 11 means as a new column in blank_corrected named "df<i>_bc"

  TAKE base-10 logarithm of all numeric values in blank_corrected
  STORE as log_df

  SET x = log_df["Fluor_conc"]

  INITIALISE empty lists: slopes, r2_vals

  FOR each experiment column index col from 2 to 16 in log_df:
      SET y = log_df[column col]   # corresponds to df1_bc, df2_bc, ...

      FIT linear model y = m * x + b using polyfit
      COMPUTE predicted values y_pred = m * x + b

      COMPUTE residual sum of squares ss_res = Σ (y - y_pred)^2
      COMPUTE total sum of squares ss_tot   = Σ (y - mean(y))^2
      COMPUTE R² = 1 - ss_res / ss_tot

      APPEND slope m to slopes
      APPEND R² to r2_vals

  CREATE experiment_numbers = [1, 2, ..., 15]
  BUILD dataframe final_df with columns:
      "Experiment Number" = experiment_numbers
      "Gradient"          = slopes
      "R2"                = r2_vals

  WRITE final_df to "BB_gradient.xlsx"

  CREATE dataframe stdev with:
      "Column"     = columns
      "Fluor_conc" = fluor_conc

  FOR experiment i from 1 to 15:

      READ Excel file "bb<i>.xlsx" again (same range as before)
      FOR each of the 11 columns:
          CALCULATE standard deviation over the 9 rows
      STORE the 11 std values as a new column in stdev named "df<i>_bc"

  INITIALISE empty list global_cv

  FOR experiment column index col from 2 to 16 in w:
      CALCULATE mean CV across all 11 rows in that column
      APPEND this mean to global_cv

  PRINT global_cv  # one average CV value per experiment

END

```